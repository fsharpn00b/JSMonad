/* Copyright 2017 FSharpN00b.
This file is part of JS Monad.

JS Monad is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

JS Monad is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with JS Monad.  If not, see <http://www.gnu.org/licenses/>. */

`use strict`;

/* Notes:
For more information about Peg.js, see:
https://pegjs.org/

There are two ways to generate a parser with Peg.js.

1. Programmatically. This is done as follows.

	let fs = require (`fs`);
	let pegjs = require (`pegjs`);
	let grammar = fs.readFileSync(`./grammar.txt`, `utf-8`);
	let parser = pegjs.generate (grammar);
	let result = parser.parse (text_to_parse);

2. Manually, using the pegjs application. At the command prompt, type:

	> pegjs grammar.txt

This outputs grammar.js. We can use the generated parser as follows.

	let parser = require (`./grammar.js`);	
	let result = parser.parse (text_to_parse);

Do not generate the parser programmatically. We need to use require in grammar.txt. If we generate the parser programmatically,
and try to use require in grammar.txt, the require path starts from the location of the Peg.js compiler rather than the location
of grammar.txt. If the Peg.js module is installed locally, we believe the compiler location is:

	<JS Monad project folder>/node_modules/pegjs/lib/compiler

That means we must require common.js with the following path.

	let common = require (`../../../../Parser/common.js`);

However, that is not a workable solution because the Peg.js module might be installed globally instead of locally, in which case
we would not know the relative path to common.js.

One potential workaround is to include common.js rather than require it. This is done as follows.

	let fs = require (`fs`);
	let vm = require (`vm`);
	function include (path) {
		let code = fs.readFileSync (path, `utf-8`);
		vm.runInThisContext (code, path);
	}
	include (`./common.js`);

When we use include in grammar.txt, the path starts from the same location as grammar.txt. However, we need to require the option
module in common.js. For some reason, if we generate the parser programmatically and include common.js in grammar.txt, we cannot
use require in common.js; the JS interpreter raises an error saying that require is not defined.
*/

/* This is the file generated by Peg.js from grammar.txt. */
let parser = require (`./grammar.js`);
let common = require (`./common.js`);

/* TODO1 We need to escape quotes and backslashes using a function like PHP's addcslashes. */

/* parse_branch
Parses the contents of an if/else if/else branch in monadic code.

Example usage:
This function is for internal use only.

Remarks:
None.

@branch - An if/else if/else branch.
@return - The result of parsing @branch.
*/
function parse_branch (branch /* : Branch */) /* : string */ {
	/* Apply the parser to the contents of the branch. */
	let code = `parser.parse (\`${branch.body}\`)`;
	/* When evaluating monadic code, the contents of an if/else if/else branch is treated as a nested block of monadic code that
	returns a monadic type value. So when we parse an if/else if/else branch, we recursively apply Monad.monad_eval_helper to the
	parsed code, and apply unit2 to the return value. */
	let code_ = `unit2 (this.monad_eval_helper (${code}, _context));`
	/* Enclose the code in the if/else if/else branch and braces. */
	return `${branch.predicate} {${code_}}`;
}

/* parse
Parses monadic code.

Example usage:
This function is for internal use only.

Remarks:
None.

@code - The monadic code to parse.
@return - The parsed @code.
*/
function parse (code /* : string */) /* : Array */ {
	let result = parser.parse (code);
	return result.map (function (item) {
		if (false === item instanceof common.IfGroup) {
			return item;
		}
		else {
			let if_branch = parse_branch (item.if_branch);
			/* There might be multiple else if branches, so parse them and concatenate the results. */
			let else_if_branches = item.else_if_branches.reduce (function (acc, item) {
				return `${acc}${parse_branch (item)}`;
			}, ``);
			/* There might or might not be an else branch. If there is, parse it. */
			var else_branch = ``;
			if (true === item.else_branch.is_Some) {
				else_branch = parse_branch (item.else_branch.value);
			}
			return `${if_branch}${else_if_branches}${else_branch}`;
		}
	});
}

module.exports.parse = parse;
